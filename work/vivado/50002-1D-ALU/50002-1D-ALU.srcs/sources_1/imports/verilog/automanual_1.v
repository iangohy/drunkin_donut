/*
   This file was generated automatically by Alchitry Labs version 1.2.7.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module automanual_1 (
    input clk,
    input rst,
    input buttonNext,
    input [7:0] inputMoreSig,
    input [7:0] inputLessSig,
    input force_error,
    input reset_counter,
    output reg [15:0] out,
    output reg [7:0] misc_states
  );
  
  
  
  wire [16-1:0] M_manual_out;
  wire [3-1:0] M_manual_zvn;
  wire [3-1:0] M_manual_state;
  reg [1-1:0] M_manual_buttonNext;
  reg [8-1:0] M_manual_inputMoreSig;
  reg [8-1:0] M_manual_inputLessSig;
  alu_control_3 manual (
    .clk(clk),
    .rst(rst),
    .buttonNext(M_manual_buttonNext),
    .inputMoreSig(M_manual_inputMoreSig),
    .inputLessSig(M_manual_inputLessSig),
    .out(M_manual_out),
    .zvn(M_manual_zvn),
    .state(M_manual_state)
  );
  
  wire [5-1:0] M_auto_counter;
  wire [2-1:0] M_auto_error;
  wire [16-1:0] M_auto_debugSum;
  reg [1-1:0] M_auto_force_error;
  reg [1-1:0] M_auto_pausing_counter_reset;
  tester_4 auto (
    .clk(clk),
    .rst(rst),
    .force_error(M_auto_force_error),
    .pausing_counter_reset(M_auto_pausing_counter_reset),
    .counter(M_auto_counter),
    .error(M_auto_error),
    .debugSum(M_auto_debugSum)
  );
  
  wire [(4'h8+0)-1:0] M_zvn_sel_out;
  reg [(4'h8+0)-1:0] M_zvn_sel_s;
  reg [(4'h8+0)-1:0] M_zvn_sel_a;
  reg [(4'h8+0)-1:0] M_zvn_sel_b;
  
  genvar GEN_zvn_sel0;
  generate
  for (GEN_zvn_sel0=0;GEN_zvn_sel0<4'h8;GEN_zvn_sel0=GEN_zvn_sel0+1) begin: zvn_sel_gen_0
    mux_2_5 zvn_sel (
      .s(M_zvn_sel_s[GEN_zvn_sel0*(1)+(1)-1-:(1)]),
      .a(M_zvn_sel_a[GEN_zvn_sel0*(1)+(1)-1-:(1)]),
      .b(M_zvn_sel_b[GEN_zvn_sel0*(1)+(1)-1-:(1)]),
      .out(M_zvn_sel_out[GEN_zvn_sel0*(1)+(1)-1-:(1)])
    );
  end
  endgenerate
  
  wire [(5'h10+0)-1:0] M_mode_sel_out;
  reg [(5'h10+0)-1:0] M_mode_sel_s;
  reg [(5'h10+0)-1:0] M_mode_sel_a;
  reg [(5'h10+0)-1:0] M_mode_sel_b;
  
  genvar GEN_mode_sel0;
  generate
  for (GEN_mode_sel0=0;GEN_mode_sel0<5'h10;GEN_mode_sel0=GEN_mode_sel0+1) begin: mode_sel_gen_0
    mux_2_5 mode_sel (
      .s(M_mode_sel_s[GEN_mode_sel0*(1)+(1)-1-:(1)]),
      .a(M_mode_sel_a[GEN_mode_sel0*(1)+(1)-1-:(1)]),
      .b(M_mode_sel_b[GEN_mode_sel0*(1)+(1)-1-:(1)]),
      .out(M_mode_sel_out[GEN_mode_sel0*(1)+(1)-1-:(1)])
    );
  end
  endgenerate
  
  reg [15:0] manual_out;
  
  reg [2:0] manual_zvn;
  
  reg [2:0] manual_state;
  
  reg [7:0] combine_zs;
  
  reg [15:0] auto_sum;
  
  reg [4:0] auto_counter;
  
  reg [1:0] auto_error;
  
  reg [7:0] combine_c;
  
  integer i;
  
  always @* begin
    M_manual_inputMoreSig = inputMoreSig;
    M_manual_inputLessSig = inputLessSig;
    M_manual_buttonNext = buttonNext;
    manual_out = M_manual_out;
    manual_zvn = M_manual_zvn;
    manual_state = M_manual_state;
    combine_zs[0+2-:3] = manual_state;
    combine_zs[5+2-:3] = manual_zvn;
    combine_zs[3+1-:2] = 2'h0;
    M_auto_pausing_counter_reset = reset_counter;
    M_auto_force_error = force_error;
    auto_sum = M_auto_debugSum;
    auto_counter = M_auto_counter;
    auto_error = M_auto_error;
    combine_c[0+4-:5] = M_auto_counter;
    combine_c[6+1-:2] = auto_error;
    combine_c[5+0-:1] = 1'h0;
    for (i = 1'h0; i < 5'h10; i = i + 1) begin
      M_mode_sel_a[(i)*1+0-:1] = auto_sum[(i)*1+0-:1];
      M_mode_sel_b[(i)*1+0-:1] = manual_out[(i)*1+0-:1];
      M_mode_sel_s[(i)*1+0-:1] = reset_counter;
      out[(i)*1+0-:1] = M_mode_sel_out[(i)*1+0-:1];
    end
    for (i = 1'h0; i < 4'h8; i = i + 1) begin
      M_zvn_sel_a[(i)*1+0-:1] = combine_c[(i)*1+0-:1];
      M_zvn_sel_b[(i)*1+0-:1] = combine_zs[(i)*1+0-:1];
      M_zvn_sel_s[(i)*1+0-:1] = reset_counter;
      misc_states[(i)*1+0-:1] = M_zvn_sel_out[(i)*1+0-:1];
    end
  end
endmodule
